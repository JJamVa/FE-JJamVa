# function 심화

## 구조분해할당 함수

- 구조분해 할당을 통해 함수에 전달하는 인자의 기본값을 지정

```js
function print({ name, age } = {}) {
  console.log(`이름: ${name}, 나이: ${age}`);
}

const person = {
  name: "JJam",
  age: 20,
};

print(person); // 이름: 'JJam', 나이: 20
print(); // 이름: undefined, 나이: undefined
```

:::tip
print함수 Parameter(파라미터)가 빈 객체이다.<br/>
만약 Parameter값을 초기화 하지않았을 경우 `print()`를 실행하면 오류가 발생한다.<br/>
꼭 **Parameter에 초기화 값을 할당** 해야된다.

:::

## rest 문법

- 함수 Parameter 변수에 `...`을 붙여 Parameter가 받을 수 있는 개수보다 Argument의 작성 개수가 더 많을 경우 초과된 값을 배열로 생성 후 지정

```js
function func(a, b, ...c) {
  console.log(a); //'hello'
  console.log(b); //'world'
  console.log(c); //[10,20,30,40]
  return Math.max(...c); //40을 반환
}

함수2("hello", "world", 10, 20, 30, 40);
```

:::danger
`rest문법 주의점`

1. Parameter(파라미터)에 단 하나의 `rest`만 존재.
2. `rest`는 Parameter(파라미터)의 무조건 맨 마지막 변수

:::

:::tip
`...(Spread문법)`vs`...(Rest 문법)`

생김새는 똑같지만 사용의 목적이 다르다.<br/>
`Spread`: 배열이나 객체의 요소를 복사하거나 병합하는데 사용<br/>
`Rest`: 매개변수에서 사용되면서, 나머지 Parameter 변수들을 배열로 받아오는데 사용
:::

## Scope

- 변수와 함수의 접근성 및 생존 범위를 의미

```js
const a = 10;

const calc = function () {
  const a = 100;
  const b = 200;
  console.log(a + b); //300
};

calc();
```

:::note
`const a = 10`은 전역 변수임에도 불구하고 `calc함수`에서는 출력은 300을 보여준다.<br/>
calc함수 안 `a + b`의 연산에서 `a`는 전역 변수 `a`가 아닌 지역 변수 `a`를 참조한다.<br/>
이 때, a는 `변수의 섀도잉(Shadowing)`이라고 부른다.<br/>
즉, 지역 변수가 동일한 이름의 전역 변수를 가린다.<br/>
calc함수가 종료되면 calc함수 안의 `a`가 가비지 컬렉션으로 수거되면서 메모리 상에서 제거 된다.<br/>
Scope는 변수명이 중복되어 충돌하는 문제를 덜어주고, 자동으로 메모리를 관리

:::

### Scope의 종류

- `전역 스코프`(Global Scope)

  - 코드의 어느 곳에서든 접근할 수 있는 변수를 포함
  - 사용이 간편하지만, 다른 스크립트와 변수 이름이 충돌할 가능성이 있어 주의

- `지역 스코프`(Local Scope)

  - 특정 부분에서만 변수에 접근할 수 있도록 제한
  - 주로 함수 내부, 조건문, 반복문에서 생성
  - 함수 내에서 선언된 변수는 함수 외부에서 접근 불가

- `함수 스코프`(Function Scope)

  - var로 선언된 변수가 해당
  - 함수 내에서 선언된 변수는 함수 외부에서 접근할 수 없으며, 함수 내의 어느 곳에서나 접근 가능
  - 함수가 종료되면 함수 내에서 선언된 var 변수는 메모리에서 해제

- `블록 스코프`(Block Scope)
  - `{}` 중괄호로 둘러싸인 내부에서 선언된 let과 const 변수에 해당
  - 블록 외부에서는 블록 내부에서 선언된 변수에 접근 불가
  - 블록 실행이 종료되면 블록 내에서 선언된 변수는 메모리에서 해제

<details>
<summary>Scope 연습</summary>
<div markdown="1">

```js
let a = 10;

function outer() {
  let b = 20;
  const c = 10;

  function inner() {
    let a = 100;
    var c = 200;
    console.log("inner:", a, b, c); // 100 20 200
  }

  inner();

  if (a !== 20) {
    const a = 1000;
    let b = 50;
    console.log("outer if:", a, b, c); // 1000 50 10
  }
  console.log("outer:", a, b, c); // 10 20 10
  a += 50;
}

outer();
console.log("global:", a, b, c); // 60 Reference Error Reference Error
```

:::note

코드 구조는 outer 함수가 선언되어있고, 내부 inner함수를 선언 및 실행되는 코드<br/>

- **"inner"** 출력:

  - a: `inner함수의 지역 스코프`로 inner함수에 선언된 a값을 참조.
  - b: `outer함수의 지역 스코프`로 outer함수에서 b의 값을 참조.
  - c: `inner함수의 함수 스코프`로 outer함수의 c값이 섀도잉이 되어 inner함수의 c값을 참조

- **outer if** 출력:

  - a: `블록 스코프`로 if문 안의 a값을 참조
  - b: `블록 스코프`로 outer함수의 b값은 섀도잉이 되어 if문 안의 b값을 참조
  - c: `지역 스코프`로 outer함수에 선언된 c값을 참조

- **outer** 출력:

  - a: `지역 스코프`로 전역에 선언된 a값을 참조
  - b: `inner함수의 지역 스코프`로 outer함수에서 선언된 b값을 참조(if문의 영향을 받지 않음)
  - c: `inner함수의 지역 스코프`로 outer함수에서 선언된 c값을 참조(inner함수의 영향을 받지 않음)

- **global** 출력:
  - a: `전역 스코프`로 전역에 선언된 a값과 outer함수안 a의 합연산 실행된 후, 출력
  - b 와 c: `접근 불가 오류`. b와 c는 outer함수의 지역 스코프에 속해 있기때문에 전역에서 접근이 불가능

:::

</div>
</details>

## 함수의 호이스팅(Hoisting)

- `Hoisting`: 끌어 올리다
- 변수나 함수 선언문이 해당 스코프의 최상단으로 끌어올려지는 현상
- 코드에서 변수나 함수를 선언하기 전에 해당 변수나 함수를 사용할 수 있는 것처럼 보이는 현상을 의미

```js
console.log(z); //undefined
console.log(y); //not defined
console.log(x); //not defined
sayHi(); //"Hello World!"

const z = 200;
var x = 100;
let y = 150;

//함수 선언문
function sayHi() {
  console.log(a); //undefined
  console.log(b); //Reference Error
  console.log(c); //Reference Error
  var a = 10;
  let b = 20;
  const c = 30;
  console.log("Hello World!");
}
```

:::note
변수와 함수를 선언하기 전에 각각 참조하고 있다.<br/>
실행 결과는 변수 x는 undefined로, 함수 sayHi함수는 "Hello World!"가 출력<br/>
`호이스팅(Hoisting)`에 의해 변수와 함수가 스코프의 최상단으로 끌어올려졌기 때문이다.

호이스팅은 **변수의 선언만** 끌어올리기 때문에 변수의 값이 할당되기 전 참조하여 **undefined**가 된 것을 확인할 수 있다.

```js
//함수 표현식
console.log(f1()); //Error
let f1 = function () {
  console.log(x); //undefined
  var x = 10;
};

//함수 선언식
console.log(f1()); //undefined
function f1() {
  console.log(x); //undefined
  var x = 10;
}
```

**함수 표현식**은 변수 선언만을 끌어올리기 때문에 함수를 선언하기 전에 함수를 호출하면 **에러가 발생**<br/>
**함수 선언문**은 전체를 끌어올리기 때문에 함수를 선언하기 전에 함수 호출이 가능하다.

var은 선언문만 호이스팅이 되고 값은 초기화 되지 않아 undefined가 출력<br/>
let, const, class를 이용한 선언문은 TDZ때문에 호이스팅이 되었지만 안된 것처럼 동작<br/>
호이스팅에 의해 **의도치 않은 결과**, **코드 가독성**, **유지보수**를 위해 동작을 막은 것이다.

:::

:::tip
**TDZ(Temporal Dead Zone)란?**

`let`과 `const`는 초기화가 실행된 후에 TDZ에서 제거되어 사용 가능한 상태된다.<br/>
TDZ는 접근이 불가능하기 때문에 초기화 전에 TDZ에 배치된 변수(`let`,`const`)에 접근하려고 하면 에러를 발생시키게 된다.

:::

## 클로저(Closure)

- `Closure`: 폐쇠된 공간 안에 데이터에 접근
- 함수안에 함수가 정의된 상태
- **내부 함수가 외부 함수에 접근** 가능
- 클로저를 사용하면 특정 변수나 함수를 외부에서 접근할 수 없도록 숨길 수 있다. 이를 이용하여 private 변수와 메서드를 구현 가능

```js
function add(x) {
  var y = 20;
  return function (z) {
    let y = 30;
    return x + y + z;
  };
}

let value = add(10);

console.log(value(10)); // 50
```

:::note
`let value = add(10)`를 통해 add함수에 Argument값인 10을 전달했다.<br/>
외부 함수에는 변수 y와 return을 통해 함수를 반환하여 변수 value에 저장한다.<br/>
value에 Argument값을 넣어 add함수 내부에 있는 반환 받은 함수를 실행시킨다.

value는 함수를 반환받아 할당하였기 때문에 value에 Argument값을 전달하여 호출한다.<br/>
내부 함수에서도 `x + y + z`의 값을 반환하는데 변수 y와 전달받은 Parameter값인 z는 존재하지만 x값은 어디에???<br/>
Closure는 **내부 함수가 외부 함수의 데이터에 접근 가능하기 때문**에 외부 함수인 adder의 Parameter x값을 사용 가능하다<br/>
x + y + z가 내부 함수의 return 값이기 때문에 50인것을 확인할 수 있다.

:::

## 생성자 함수 (Constructor)

- 객체를 생성하는 방식
  - 객체 리터렬 표현식, 생성자 함수를 이용한 방식
- 일반 함수와 구분하기 위해 생성자 함수 이름 **첫 글자는 대문자**
- `new` 연산자를 붙여 실행
  - **new 연산자는 생성자 함수의 this 가 인스턴스**를 바라보도록 만들어주는 역할

```js
function Person(name, age, iq, eq) {
  this.name = name;
  this.age = age;
  this.iq = iq;
  this.eq = eq;
}

let human1 = new Person("JJamVa", 20, 130, 120);
let human2 = new Person("BJsha", 22, 150, 200);
let human3 = Person("RoPaChoi", 15, 140, 130);

console.log(human1, human2, human3);
// Person {name: 'JJamVa', age: 20, iq: 130, eq: 120}
// Person {name: 'BJsha', age: 22, iq: 150, eq: 200}
// undefined
```

:::note

```js
let human3 = Person("RoPaChoi", 15, 140, 130);
```

왜 undefined가 나올까?<br/>

`new`연산자로 통해 this가 객체 Person을 지목함으로서 객체의 값을 저장할 수 있다.<br/>
human3와 같은 경우에는 `new`연산자를 사용하지 않았기 때문에 this는 전역을 지목하고 있다.<br/>
즉, 위의 코드에서의 this는 window객체를 지목하고 있으며<br/>
window의 존재하지 않는 key값들을 참조하려 했기 때문에 `undefined`가 출력된 것이다.

:::

:::tip

### 생성자 함수를 사용하는 이유?

1. 동일한 속성을 가지는 객체를 여러번 생성가능
2. prototype을 이용하여 메모리 효율을 높일 수 있다.
3. 유지보수 및 관리에 매우 용이

:::
