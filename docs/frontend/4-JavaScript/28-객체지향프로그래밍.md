# 객체지향 프로그래밍

## 객체지향 프로그래밍이란?

- 프로그램을 작성할 때 객체들을 만들어 서로 소통하도록하는 방법

:::note
객체(Object)란??

객체 지향의 객체는 표현하고자 하는 사물을 **추상적으로 표현**
:::

```js
const person = {
  name: "JJamVa",
  nextYear: function (currentAge) {
    currentAge.ageUp();
  },
};

const person1 = {
  age: 12,
  ageUp: function () {
    this.age++;
  },
};

person.nextYear(person1);
console.log(person1); // {age:13, ageUp:f}
```

## 생성자(constructor)

- 객체를 만들 때, **new연산자**와 함께 사용하는 함수

### 생성자 만들기

- 생성자를 생성할 때, 함수처럼 사용하지만 **함수의 이름을 맨앞의 글자를 대문자**로 작성

```js
function Person() {}
let person1 = new Person(); // instance라고 부름
```

### 생성자 확인 방법(`instanceof`)

- 생성자 함수에는 return이 없지만 new연산자를 통해 객체(`instance`)를 반환한다.
- 생성자 함수에서 생성된 객체인지 확인하기 위해 `instanceof`를 통해 확인한다.
- 반환값은 `true`, `false`

```js
function Person(name) {
    this.name = name,
    this.speak = function () {
      console.log(`내이름은 ${this.name} 입니다.`);
    };
}
let person1 = new Person("JJamVa");
let person2 = Person("JJamVa");

console.log(person1 instanceof Person); //true
console.log(person2 instanceof Person); //false
```

:::tip

### new의 존재 여부

```js
console.log(person1); // Person {name: 'JJamVa', speak: ƒ}
console.log(person2); // undefined
```

위의 코드 기반으로 person1과 person2의 출력을 확인해보았다.<br/>
person1은 instance의 정보를 출력하고 있지만 person2는 undefined가 출력되었다.<br/>
person2의 같은 경우 **new연산자가 없기 때문**에 this는 Person의 객체를 지목하는 것이 아닌 **전역 변수인 window객체**를 가르키고 있다.<br/>
추가적으로 Person이라는 생성자 함수에서는 **return이 없기 때문**에 undefined가 출력된 것이다.
:::

## 프로토타입(prototype)

- 동일한 생성자 함수로 생성된 인스턴스가 하나의 메서드를 만들어 자원을 효율적으로 관리
- `생성자함수.prototype.속성이름 = function(){}`

```js
function Person(name) {
    this.name = name,
    this.speak = function () {
      console.log(`${this.name} 출력`);
    };
}
let person1 = new Person("Hello");
let person2 = new Person("World");

console.log(person1) // {name: 'Hello', speak: ƒ}
console.log(person2) // {name: 'World', speak: ƒ}
console.log(person1.speak())// Hello 출력
console.log(person2.speak())// World 출력
```

```js
function Person(name) {
    this.name = name
}

Person.prototype.speak = function(){
    console.log(`${this.name} 출력`)
}

let person1 = new Person("Hello");
let person2 = new Person("World");

console.log(person1)// {name: 'Hello'}
console.log(person2)// {name: 'World'}
console.log(person1.speak())// Hello 출력
console.log(person2.speak())// World 출력
```

:::tip
위의 두가지 코드를 보면 결론적으로 원하는 instance에 대한 speak함수 호출은 성공적이다.<br/>
하지만 Person에 대한 instance를 출력해보면 speak함수가 객체 내에 내장되어 있는지 없는지 차이가 있다.<br/>
`prototype`으로 인해 객체내에 있는 공통된 함수를 제거함으로 메모리 절약을 했다.<br/>
또한, speak함수를 메소드로 선언함으로써 코드 재사용성을 높일 수 있다.

:::